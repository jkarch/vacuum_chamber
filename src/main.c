/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  *  Vacuum Chamber Controller
  *  Created by Joshua Karch for Eyebotix, LLC
  *  (C)2020,2021 by Joshua Karch
  *  This code is partially generated by STM32CubeMX so portions of this code 
  *  that are autogenerated are licensed by ST under Ultimate Liberty license
  *  SLA0044, the "License"; You may not use this file except in compliance with
  *  the License. You may obtain a copy of the License at:
  *                             www.st.com/SLA0044
  *  The remainder of this code is covered under
  *  MIT License
  *  Copyright (c) 2020-2021 Joshua P. Karch 
  *  
  *  Permission is hereby granted, free of charge, to any person obtaining a copy
  *  of this software and associated documentation files (the "Software"), to deal
  *  in the Software without restriction, including without limitation the rights
  *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  *  copies of the Software, and to permit persons to whom the Software is
  *  furnished to do so, subject to the following conditions:
  *  The above copyright notice and this permission notice shall be included in all
  *  copies or substantial portions of the Software.
  *  
  *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  *  SOFTWARE.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"
#include "usb_host.h"
#include "usb_host.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
//https://www.youtube.com/watch?v=uohla8zjzkk
//ADC stuff
#include <string.h>
#include <stdio.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticQueue_t osStaticMessageQDef_t;
typedef StaticTimer_t osStaticTimerDef_t;
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

I2C_HandleTypeDef hi2c1;
I2C_HandleTypeDef hi2c3;

I2S_HandleTypeDef hi2s3;

SPI_HandleTypeDef hspi1;

TIM_HandleTypeDef htim2;

UART_HandleTypeDef huart3;

/* Definitions for mainControlTask */
osThreadId_t mainControlTaskHandle;
const osThreadAttr_t mainControlTask_attributes = {
  .name = "mainControlTask",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for buttonSampTask */
osThreadId_t buttonSampTaskHandle;
const osThreadAttr_t buttonSampTask_attributes = {
  .name = "buttonSampTask",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityLow,
};
/* Definitions for LCDdisplayTask */
osThreadId_t LCDdisplayTaskHandle;
const osThreadAttr_t LCDdisplayTask_attributes = {
  .name = "LCDdisplayTask",
  .stack_size = 1024 * 4,
  .priority = (osPriority_t) osPriorityLow,
};
/* Definitions for pressureSample */
osMessageQueueId_t pressureSampleHandle;
control_packet_t pressureSampleBuffer[3];
osStaticMessageQDef_t pressureSampleControlBlock;
const osMessageQueueAttr_t pressureSample_attributes = {
  .name = "pressureSample",
  .cb_mem = &pressureSampleControlBlock,
  .cb_size = sizeof(pressureSampleControlBlock),
  .mq_mem = &pressureSampleBuffer,
  .mq_size = sizeof(pressureSampleBuffer)
};
/* Definitions for displayQueue */
osMessageQueueId_t displayQueueHandle;
control_variables_t displayQueueBuffer[3];
osStaticMessageQDef_t displayQueueControlBlock;
const osMessageQueueAttr_t displayQueue_attributes = {
  .name = "displayQueue",
  .cb_mem = &displayQueueControlBlock,
  .cb_size = sizeof(displayQueueControlBlock),
  .mq_mem = &displayQueueBuffer,
  .mq_size = sizeof(displayQueueBuffer)
};
/* Definitions for pressureSampleTimer */
osTimerId_t pressureSampleTimerHandle;
osStaticTimerDef_t pressureSampleTimerControlBlock;
const osTimerAttr_t pressureSampleTimer_attributes = {
  .name = "pressureSampleTimer",
  .cb_mem = &pressureSampleTimerControlBlock,
  .cb_size = sizeof(pressureSampleTimerControlBlock),
};
/* USER CODE BEGIN PV */
//Pressure data location for I2C ISR
volatile uint8_t pressureData[4];
//DMA storage location for Joystick ADC readings:
volatile uint16_t Joystick[2];
//button debounce structure
volatile button_debounce_t button;
//function command list
const uint8_t function_commands[3] = { SetPressure, Purge, RunContinuous };
//pressure control variables
const uint8_t row_positions[4] = { 0x00, 0x40, 0x14, 0x54 };
const char* pres_samp_mode = "Press Md";
const char* purge_mode = "Purge Md";
const char* continuous_mode = "Contin Md";

//control_packet_t pressureSampleBuffer[3];  //copy and paste this into the auto generated structure.
//control_variables_t displayQueueBuffer[3];
volatile control_variables_t ctrl_vars;

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ADC1_Init(void);
static void MX_I2C1_Init(void);
static void MX_I2S3_Init(void);
static void MX_SPI1_Init(void);
static void MX_TIM2_Init(void);
static void MX_I2C3_Init(void);
static void MX_USART3_UART_Init(void);
void controlTask(void *argument);
void buttonTask(void *argument);
void displayTask(void *argument);
void TriggerPressureSample(void *argument);

/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
	memset((void *)&button, 0, sizeof(button_debounce_t)); //erase
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_ADC1_Init();
  MX_I2C1_Init();
  MX_I2S3_Init();
  MX_SPI1_Init();
  MX_TIM2_Init();
  MX_I2C3_Init();
  MX_USART3_UART_Init();
  /* USER CODE BEGIN 2 */
	HAL_GPIO_WritePin(press_reset_GPIO_Port, press_reset_Pin, GPIO_PIN_RESET);
	osDelay(100);
	HAL_GPIO_WritePin(press_reset_GPIO_Port, press_reset_Pin, GPIO_PIN_SET);
	osDelay(100);
	HAL_TIM_Base_Start(&htim2);
	HAL_ADC_Start_DMA(&hadc1, (uint32_t*) Joystick, 2);
  /* USER CODE END 2 */

  /* Init scheduler */
  osKernelInitialize();

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* Create the timer(s) */
  /* creation of pressureSampleTimer */
  pressureSampleTimerHandle = osTimerNew(TriggerPressureSample, osTimerPeriodic, NULL, &pressureSampleTimer_attributes);

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* Create the queue(s) */
  /* creation of pressureSample */
  pressureSampleHandle = osMessageQueueNew (3, sizeof(control_packet_t), &pressureSample_attributes);

  /* creation of displayQueue */
  displayQueueHandle = osMessageQueueNew (3, sizeof(control_variables_t), &displayQueue_attributes);

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of mainControlTask */
  mainControlTaskHandle = osThreadNew(controlTask, NULL, &mainControlTask_attributes);

  /* creation of buttonSampTask */
  buttonSampTaskHandle = osThreadNew(buttonTask, NULL, &buttonSampTask_attributes);

  /* creation of LCDdisplayTask */
  LCDdisplayTaskHandle = osThreadNew(displayTask, NULL, &LCDdisplayTask_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
	osStatus_t status = osTimerStart(pressureSampleTimerHandle, PRESS_TIMER_DELAY); // start timer
	if (status != osOK) {
		// Timer could not be started
	} 
  /* USER CODE END RTOS_EVENTS */

  /* Start scheduler */
  osKernelStart();

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */
  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
  hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T2_TRGO;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 2;
  hadc1.Init.DMAContinuousRequests = ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_14;
  sConfig.Rank = 1;
  sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_15;
  sConfig.Rank = 2;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.ClockSpeed = 100000;
  hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

/**
  * @brief I2C3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C3_Init(void)
{

  /* USER CODE BEGIN I2C3_Init 0 */

  /* USER CODE END I2C3_Init 0 */

  /* USER CODE BEGIN I2C3_Init 1 */

  /* USER CODE END I2C3_Init 1 */
  hi2c3.Instance = I2C3;
  hi2c3.Init.ClockSpeed = 100000;
  hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c3.Init.OwnAddress1 = 0;
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c3.Init.OwnAddress2 = 0;
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C3_Init 2 */

  /* USER CODE END I2C3_Init 2 */

}

/**
  * @brief I2S3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2S3_Init(void)
{

  /* USER CODE BEGIN I2S3_Init 0 */

  /* USER CODE END I2S3_Init 0 */

  /* USER CODE BEGIN I2S3_Init 1 */

  /* USER CODE END I2S3_Init 1 */
  hi2s3.Instance = SPI3;
  hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
  hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
  hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
  hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
  hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_8K;
  hi2s3.Init.CPOL = I2S_CPOL_LOW;
  hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
  hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
  if (HAL_I2S_Init(&hi2s3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2S3_Init 2 */

  /* USER CODE END I2S3_Init 2 */

}

/**
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 42000;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 80;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 9600;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, CS_I2C_SPI_Pin|valve_ctrl_Pin|pump_ctrl_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
                          |Audio_RST_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(press_reset_GPIO_Port, press_reset_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : CS_I2C_SPI_Pin valve_ctrl_Pin pump_ctrl_Pin */
  GPIO_InitStruct.Pin = CS_I2C_SPI_Pin|valve_ctrl_Pin|pump_ctrl_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

  /*Configure GPIO pins : OTG_FS_PowerSwitchOn_Pin press_reset_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin|press_reset_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pin : PDM_OUT_Pin */
  GPIO_InitStruct.Pin = PDM_OUT_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
  HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : button_Pin */
  GPIO_InitStruct.Pin = button_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(button_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : BOOT1_Pin */
  GPIO_InitStruct.Pin = BOOT1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : CLK_IN_Pin */
  GPIO_InitStruct.Pin = CLK_IN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
  HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin
                           Audio_RST_Pin */
  GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
                          |Audio_RST_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /*Configure GPIO pin : press_samp_Pin */
  GPIO_InitStruct.Pin = press_samp_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(press_samp_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : OTG_FS_OverCurrent_Pin */
  GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI0_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(EXTI0_IRQn);

  HAL_NVIC_SetPriority(EXTI2_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(EXTI2_IRQn);

}

/* USER CODE BEGIN 4 */
uint32_t rawPressureDataFromBytes(uint8_t *data, size_t size)
{
	if (size == 4)
		return (uint32_t)data[3] | ((uint32_t)data[2]) << 8 | ((uint32_t)data[1] << 16);
	else return 0;
}
float processPressureSensorData(uint8_t *data, size_t size)
{
	//byte format is [status][23-16][15-8][7-0]
	//ignore status in this example
	uint32_t raw_data = (uint32_t)data[3] | ((uint32_t)data[2]) << 8 | ((uint32_t)data[1] << 16);
	return (float)((raw_data - OUTPUT_MIN)*(PRESS_MAX - PRESS_MIN)) /
		(float)((OUTPUT_MAX - OUTPUT_MIN));
	
}

float sensorDataToPressure(uint32_t value)
{
	return (((float)(value) - OUTPUT_MIN)*(PRESS_MAX - PRESS_MIN)) /
		(float)((OUTPUT_MAX - OUTPUT_MIN));
	
}


void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) 
{
	switch (GPIO_Pin)
	{
	case GPIO_PIN_0: // vac drdy, trigger receive interrupt
		
		HAL_I2C_Master_Receive_IT(&hi2c3, press_addr, (uint8_t *)pressureData, sizeof(pressureData));		
		break;
	case GPIO_PIN_2: // button press, debounce signaling
		if (button.flag_debouncing == 0)
			osThreadFlagsSet(buttonSampTaskHandle, USER_BUTTON_DETECTED);
			
		break;
	default:
		;
	}
}


//change to DMA Complete callback
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
	/* This is called after the conversion is completed */
	//send over queue?
	
	pressureSampleBuffer[0].id = analog_sample;
	pressureSampleBuffer[0].x_posn = Joystick[0];
	pressureSampleBuffer[0].y_posn = Joystick[1];
	osMessageQueuePut(pressureSampleHandle, pressureSampleBuffer, 0U, 0U);
}
void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	//on transmission, do nothing, wait for reception
}

void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	//on receipt, send data over queue to thread to decode
	pressureSampleBuffer[0].id = pressure_sample;
	pressureSampleBuffer[0].pressure_raw = rawPressureDataFromBytes((uint8_t *)pressureData, sizeof(pressureData));
	osMessageQueuePut(pressureSampleHandle, pressureSampleBuffer, 0U, 0U);
}


void debugPrintAtPos(UART_HandleTypeDef *huart, char _out[],uint8_t pos,size_t len) {
	char setpos[3] = "\xFE\x45\x00";
	setpos[2] = pos;
	HAL_UART_Transmit_IT(huart, (uint8_t *) setpos,sizeof(setpos));
	osDelay(10);
	HAL_UART_Transmit_IT(huart, (uint8_t *) _out, len);
	osDelay(20);
}
void debugPrint(UART_HandleTypeDef *huart, char _out[]) {
	HAL_UART_Transmit_IT(huart, (uint8_t *) _out, strlen(_out));
	osDelay(1);
}

void debugPrintln(UART_HandleTypeDef *huart, char _out[]) {
	HAL_UART_Transmit_IT(huart, (uint8_t *) _out, strlen(_out));
	osDelay(10);
	char home[2] = "\xFE\x46";
	HAL_UART_Transmit_IT(huart, (uint8_t *) home, 2);
	osDelay(10);
}

void debugClrScrn(UART_HandleTypeDef *huart)
{
	char clearscreen[2] = "\xFE\x51";
	HAL_UART_Transmit_IT(huart, (uint8_t *) clearscreen, 2);
	osDelay(10);
	
}
/* USER CODE END 4 */

/* USER CODE BEGIN Header_controlTask */
/**
  * @brief  Function implementing the mainControlTask thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_controlTask */
void controlTask(void *argument)
{
  /* init code for USB_HOST */
  MX_USB_HOST_Init();
  /* USER CODE BEGIN 5 */
	osStatus_t status;
	

	
	uint32_t timer_x = 0;
	uint32_t timer_y = 0;
	int32_t function_index = 1;
	ctrl_vars.current_pressure_setpoint = DEFAULT_PRESSURE_SETPOINT;
	ctrl_vars.desired_pressure_setpoint = DEFAULT_PRESSURE_SETPOINT;
	ctrl_vars.current_command = function_commands[function_index];  //index 1 is purge
	ctrl_vars.desired_command = function_commands[function_index];	//index 1 is purge
	
	debugClrScrn(&huart3);
  /* Infinite loop */
  for(;;)
  {
	  status = osMessageQueueGet(pressureSampleHandle, pressureSampleBuffer, NULL, osWaitForever); // wait for message
	  if (status == osOK) {
		  //look at ID and either store pressure sample or act on "debounced" joystick input or "commit changes" if button pressed.
		  switch (pressureSampleBuffer[0].id)
		  {
		  case pressure_sample:
			  ctrl_vars.measured_pressure = sensorDataToPressure(pressureSampleBuffer[0].pressure_raw);
			  //perform controls here...
			  switch (ctrl_vars.current_command)
			  {
			  case SetPressure:
				  if (ctrl_vars.pump_cmd == 1)
				  {
					  //if pump is already on
					  if (ctrl_vars.measured_pressure < (ctrl_vars.current_pressure_setpoint-(float)OFF_HYSTERESIS))
					  {
						  ctrl_vars.pump_cmd = 0;
						  ctrl_vars.valve_cmd = 0;
					  }
				  }
				  else if (ctrl_vars.measured_pressure > ctrl_vars.current_pressure_setpoint)
				  {
					  ctrl_vars.pump_cmd = 1;
					  ctrl_vars.valve_cmd = 0;
				  }
				  else if (ctrl_vars.measured_pressure < (ctrl_vars.current_pressure_setpoint-PURGE_HYSTERESIS))
				  {
					  ctrl_vars.pump_cmd = 0;
					  ctrl_vars.valve_cmd = 1;
				  }

				  break;
			  case Purge:
				  ctrl_vars.pump_cmd = 0;
				  ctrl_vars.valve_cmd = 1;
				  ctrl_vars.desired_pressure_setpoint = DEFAULT_PRESSURE_SETPOINT;
				  break;
			  case RunContinuous:
				  ctrl_vars.pump_cmd = 1;
				  ctrl_vars.valve_cmd = 0;
				  ctrl_vars.desired_pressure_setpoint = DEFAULT_PRESSURE_SETPOINT;
				  break;
			  default:
				  ;
				  
				  
			  }
			  
			  HAL_GPIO_WritePin(GPIOE, pump_ctrl_Pin, ctrl_vars.pump_cmd);
			  HAL_GPIO_WritePin(GPIOE, valve_ctrl_Pin, ctrl_vars.valve_cmd);
			  
			  
			  break;
		  case analog_sample:
			  if (ctrl_vars.current_command == SetPressure)  // only in set pressure mode is desired setpoint captured, consider CLAMPING FUNCTION in refactor
			  {
				  if ((pressureSampleBuffer[0].y_posn > UP_RIGHT_THRESHOLD) || (pressureSampleBuffer[0].y_posn < DOWN_LEFT_THRESHOLD))
				  {
					  if (timer_y > JOY_TIMER_TIMEOUT)
					  {
						  timer_y = 0;
						  ctrl_vars.desired_pressure_setpoint =  ctrl_vars.desired_pressure_setpoint + ((pressureSampleBuffer[0].y_posn > UP_RIGHT_THRESHOLD) ? 0.1 : -0.1);
						  if (ctrl_vars.desired_pressure_setpoint > MAX_PRESSURE_SETPOINT)
							  ctrl_vars.desired_pressure_setpoint = MAX_PRESSURE_SETPOINT;
						  if (ctrl_vars.desired_pressure_setpoint < MIN_PRESSURE_SETPOINT)
							  ctrl_vars.desired_pressure_setpoint = MIN_PRESSURE_SETPOINT;
					  }
					  else
					  {
						  timer_y++;
					  }	  
				  }
			  }  else
			  {
				  timer_y = 0;
			  }

			  if ((pressureSampleBuffer[0].x_posn > UP_RIGHT_THRESHOLD) || (pressureSampleBuffer[0].x_posn < DOWN_LEFT_THRESHOLD))
			  {
				  if (timer_x > JOY_TIMER_TIMEOUT)
				  {
					  timer_x = 0;
					  function_index = function_index + ((pressureSampleBuffer[0].x_posn > UP_RIGHT_THRESHOLD) ? 1 : -1);
					  //wrap forward and backward, mod not used.
					  if (function_index < 0) function_index = sizeof(function_commands) - 1;
					  if (function_index > sizeof(function_commands) - 1) function_index = 0;
					  ctrl_vars.desired_command = function_commands[function_index];
				  }
				  else
				  {
					  timer_x++;
				  }
			  }
			  else
			  {
				  timer_x = 0;
			  }
			  
			  //run display at the slower analog acquistion rate
			  
			  memcpy(&displayQueueBuffer[0], (void *)&ctrl_vars, sizeof(displayQueueBuffer[0]));
			  status = osMessageQueuePut(displayQueueHandle, displayQueueBuffer, 0U, 0U);


			  break;
		  case button_pressed:
			  ctrl_vars.current_command = ctrl_vars.desired_command;
			  if (ctrl_vars.current_command == SetPressure) 
				  ctrl_vars.current_pressure_setpoint = ctrl_vars.desired_pressure_setpoint;
			  //commit changes to command or setpoint here.
		  default:
			  ;
		  }
		  

	  }
	  
	  //check status here

      //queue out to display task
	  osThreadYield(); // suspend thread
  }
  /* USER CODE END 5 */
}

/* USER CODE BEGIN Header_buttonTask */
/**
* @brief Function implementing the buttonSampTask thread.
* @param argument: Not used
* @retval None
* https://electronics.stackexchange.com/questions/290592/use-stm32-interrupt-with-freertos
*/
/* USER CODE END Header_buttonTask */
void buttonTask(void *argument)
{
  /* USER CODE BEGIN buttonTask */
	button.value = BUTTON_IS_RELEASED;
	button.flag_debouncing = 0;
  /* Infinite loop */
  for(;;)
  {
	osThreadFlagsWait(USER_BUTTON_DETECTED,osFlagsWaitAny, osWaitForever);
	button.value = BUTTON_IS_PRESSED;
	button.flag_debouncing = 1;

	/*
		* Debounce loop
		* Button was pressed. Wait for its release.
		* Debounce by checking every 10msec until released level is seen unchanged (5 times)
		*/
	for (button.debounce_ctr = STABLE_LEVEL_COUNTER; button.debounce_ctr > 0; button.debounce_ctr--)
	{
		osDelay(USER_BUTTON_DEBOUNCE_STEP__MSEC);

		/*
			* Time 10 msec has passed. If the button is still pressed, restart the debouncing
			*/
		if (HAL_GPIO_ReadPin(GPIOA, button_Pin) == BUTTON_IS_PRESSED)
		{
			button.debounce_ctr = RELOAD_THE_COUNTER; // not released = not stable... restart the counter and wait more
		}
	}

	/*
		* Button is debounced
		*/
	
		
	button.value = BUTTON_IS_RELEASED;
	button.flag_debouncing = 0;
	
	//send message that button press happened
	  pressureSampleBuffer[0].id = button_pressed;
	  osMessageQueuePut(pressureSampleHandle, pressureSampleBuffer, 0U, 0U);

	osDelay(1);

  }
  /* USER CODE END buttonTask */
}

/* USER CODE BEGIN Header_displayTask */
/**
* @brief Function implementing the LCDdisplayTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_displayTask */
void displayTask(void *argument)
{
  /* USER CODE BEGIN displayTask */
  /* Infinite loop */
	osStatus_t status;
	char display_val[20];
	memset(display_val, ' ', sizeof(display_val));
	


	int printed_length = 0;
  for(;;)
  {
	  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, HAL_GPIO_ReadPin(GPIOD, GPIO_PIN_15) ^ 1);
	  status = osMessageQueueGet(displayQueueHandle, displayQueueBuffer, NULL, osWaitForever); // wait for message
	  if (status == osOK) {
		  
		  
		  memset(display_val, ' ', sizeof(display_val));
		  printed_length = sprintf(display_val,
			  "CPr:%02.2f Set:%02.2f",
			  displayQueueBuffer[0].measured_pressure,
			  displayQueueBuffer[0].current_pressure_setpoint
			  );
		  
		  //displayQueueBuffer[0].desired_pressure_setpoint
		  //debugPrintln(&huart3,display_val);
		  display_val[printed_length] = ' ';
		  debugPrintAtPos(&huart3, display_val,row_positions[0],sizeof(display_val));
		  memset(display_val, ' ', sizeof(display_val));
		  
		  switch (displayQueueBuffer[0].current_command)
		  {
		  case SetPressure:
			  printed_length = sprintf(display_val,
				  "%s Setp:%02.2f",pres_samp_mode,
				  displayQueueBuffer[0].desired_pressure_setpoint);
		  
			  
			  break;
		  case Purge:
			  printed_length = sprintf(display_val,
				  "%s",
				  purge_mode);

			  break;
		  case RunContinuous:
			  printed_length = sprintf(display_val,
				  "%s",
				  continuous_mode);
			  break;
		  default:
			  ;
		  }
		  display_val[printed_length] = ' ';
		  debugPrintAtPos(&huart3, display_val, row_positions[1],sizeof(display_val));
		  memset(display_val, ' ', sizeof(display_val));
		  
		  switch (displayQueueBuffer[0].desired_command)
		  {
		  case SetPressure:
			  printed_length = sprintf(display_val,
				  "Select: %s",
				  pres_samp_mode);
		    
			  break;
		  case Purge:
			  printed_length = sprintf(display_val,
				  "Select: %s",
				  purge_mode);

			  break;
		  case RunContinuous:
			  printed_length = sprintf(display_val,
				  "Select: %s",
				  continuous_mode);
			  break;
		  default:
			  ;
		  }
		  display_val[printed_length] = ' ';
		  debugPrintAtPos(&huart3, display_val, row_positions[2],sizeof(display_val));
		  memset(display_val, ' ', sizeof(display_val));
		  
		  printed_length = sprintf(display_val,
			  "Pump: %1u Valve %1u",
			  displayQueueBuffer[0].pump_cmd,
			  displayQueueBuffer[0].valve_cmd);
		  display_val[printed_length] = ' ';
		  debugPrintAtPos(&huart3, display_val, row_positions[3],sizeof(display_val));	  
		  memset(display_val, ' ', sizeof(display_val));
		  
		 
		  
		  
		  /*for(int i = 0 ; i < printed_length ; i++) {
		  		debugPrint(&huart3, "\xFE\x49") ; //step back cursor that many times.
	  		}*/
	  }
	  osThreadYield();
  }
  /* USER CODE END displayTask */
}

/* TriggerPressureSample function */
void TriggerPressureSample(void *argument)
{
  /* USER CODE BEGIN TriggerPressureSample */
	HAL_I2C_Master_Transmit_IT(&hi2c3, press_addr, request_sample, sizeof(request_sample)); //signal to start i2c data transmission
  /* USER CODE END TriggerPressureSample */
}

/**
  * @brief  Period elapsed callback in non blocking mode
  * @note   This function is called  when TIM1 interrupt took place, inside
  * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
